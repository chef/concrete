%% -*- mode: erlang -*-
%% -*- tab-width: 4;erlang-indent-level: 4;indent-tabs-mode: nil -*-
%% ex: ts=4 sw=4 ft=erlang et

%% rebar.config.script GENERATED BY concrete
%%
%% YOU SHOULDN'T NEED TO EDIT THIS FILE
%%
{concrete_rebar_script_version, 1}.

%% We need the following helper function to merge dev only options
%% into the values provided by rebar.config.

%% Merge the list values in `ToAdd' into the list found at key `Key'
%% in proplist `C'. Don't duplicate items. New Items are added to the
%% front of existing items. It is an error if the value at `Key' is
%% not a list in `C'.
MergeConfig = fun({Key, ToAdd}, C) ->
                      case lists:keyfind(Key, 1, C) of
                          false ->
                              lists:keystore(Key, 1, C, {Key, ToAdd});
                          {Key, List} when is_list(List) ->
                              %% remove items in ToAdd already in List
                              ToAdd1 = [ I || I <- ToAdd, not lists:member(I, List) ],
                              lists:keystore(Key, 1, C, {Key, ToAdd1 ++ List })
                      end
              end.

%% -- Add development only options if we are a top-level build  --
%%
%% If a file named `.concrete/DEV_MODE' exists, we assume we are a
%% top-level build (not being built as a dep of another project). We
%% add the deps from dev_only_deps defined in rebar.config, add
%% concrete as a dep, and define the compiler macro DEV_ONLY.

%% This macro can be used to conditionally enable code (e.g. tests)
%% that depend on development only dependencies.
ErlOpts = {erl_opts, [
    {d, 'DEV_ONLY'}
]},

%% Development only dependencies can be specified in the main
%% rebar.config. This file should not need to be edited directly.
DevOnlyDeps = case lists:keyfind(dev_only_deps, 1, CONFIG) of
                  false ->
                      [];
                  {dev_only_deps, DOD} ->
                      DOD
              end,

EdownMe =
fun(C) ->
        %% Unless rebar.config contains `{use_edown, false}', we'll
        %% wire it up. However, we'll only add the required edoc_opts
        %% if none have been provided.
        case proplists:get_value(use_edown, C) of
            false ->
                C;
            _ ->
                %% only add edoc_opts if none are present
                C1 = case lists:keymember(edoc_opts, 1, C) of
                         true ->
                             C;
                         false ->
                             MergeConfig({edoc_opts, [{doclet, edown_doclet}]}, C)
                     end,
                MergeConfig({deps,
                             [{edown, ".*",
                               {git, "git://github.com/seth/edown.git",
                                {branch, "master"}}}]},
                            C1)
        end
end,

Deps = {deps, DevOnlyDeps},

ConfigPath = filename:dirname(SCRIPT),
DevMarker = filename:join([ConfigPath, ".concrete/DEV_MODE"]),

case filelib:is_file(DevMarker) of
    true ->
        lists:foldl(fun(I, C) -> MergeConfig(I, C) end,
                    EdownMe(CONFIG), [Deps, ErlOpts]);
    false ->
        %% If the .concrete/ marker is not present, this script simply
        %% returns the config specified in rebar.config. This will be
        %% the behavior when the project is built as a dependency of
        %% another project.
        CONFIG
end.
